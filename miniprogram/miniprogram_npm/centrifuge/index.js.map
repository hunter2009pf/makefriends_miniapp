{"version":3,"sources":["index.js","centrifuge.js","subscription.js","codes.js","types.js","utils.js","transport_sockjs.js","transport_websocket.js","transport_http_stream.js","transport_sse.js","transport_webtransport.js","json.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA,AENA;AHUA,AENA,AHSA,AENA,AENA;AHUA,AENA,AHSA,AENA,AENA;AHUA,AENA,AHSA,AENA,AENA,ACHA;AJaA,AENA,AHSA,AENA,AENA,ACHA;AJaA,AENA,AHSA,AENA,AENA,ACHA;AJaA,AENA,AHSA,AENA,AIZA,AFMA,ACHA;AJaA,AENA,AHSA,AENA,AIZA,AFMA,ACHA;AJaA,AENA,AHSA,AENA,AIZA,AFMA,ACHA;AJaA,AENA,AHSA,AENA,AIZA,ACHA,AHSA,ACHA;AJaA,AENA,AHSA,AENA,AIZA,ACHA,AHSA,ACHA;AJaA,AENA,ADGA,AIZA,ACHA,AHSA,ACHA;AJaA,AENA,ADGA,AMlBA,AFMA,ACHA,AHSA,ACHA;AJaA,AENA,ADGA,AMlBA,AFMA,ACHA,AHSA,ACHA;AJaA,AENA,ADGA,AMlBA,AFMA,ACHA,AHSA,ACHA;AJaA,AENA,ADGA,AMlBA,AFMA,AGTA,AFMA,AHSA,ACHA;AJaA,AENA,ADGA,AMlBA,AFMA,AGTA,AFMA,AHSA,ACHA;AJaA,AENA,ADGA,AMlBA,AFMA,AGTA,AFMA,AHSA,ACHA;AJaA,AENA,ADGA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,ADGA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,ADGA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AENA,AQxBA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AU9BA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AU9BA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,AU9BA,AT2BA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,AFMA,AGTA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,ACHA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,ACHA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,ACHA,AFMA,AGTA,ALeA;AJaA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,AFMA,AGTA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,ACHA,ACHA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA,AENA;AT4BA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA,AMlBA;APsBA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscription = exports.Centrifuge = void 0;\nconst centrifuge_1 = require(\"./centrifuge\");\nObject.defineProperty(exports, \"Centrifuge\", { enumerable: true, get: function () { return centrifuge_1.Centrifuge; } });\nconst subscription_1 = require(\"./subscription\");\nObject.defineProperty(exports, \"Subscription\", { enumerable: true, get: function () { return subscription_1.Subscription; } });\n__exportStar(require(\"./types\"), exports);\n//# sourceMappingURL=index.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Centrifuge = void 0;\nconst subscription_1 = require(\"./subscription\");\nconst codes_1 = require(\"./codes\");\nconst transport_sockjs_1 = require(\"./transport_sockjs\");\nconst transport_websocket_1 = require(\"./transport_websocket\");\nconst transport_http_stream_1 = require(\"./transport_http_stream\");\nconst transport_sse_1 = require(\"./transport_sse\");\nconst transport_webtransport_1 = require(\"./transport_webtransport\");\nconst json_1 = require(\"./json\");\nconst utils_1 = require(\"./utils\");\nconst types_1 = require(\"./types\");\nconst events_1 = __importDefault(require(\"events\"));\nconst defaults = {\n    protocol: 'json',\n    token: null,\n    getToken: null,\n    data: null,\n    debug: false,\n    name: 'js',\n    version: '',\n    fetch: null,\n    readableStream: null,\n    websocket: null,\n    eventsource: null,\n    sockjs: null,\n    sockjsOptions: {},\n    emulationEndpoint: '/emulation',\n    minReconnectDelay: 500,\n    maxReconnectDelay: 20000,\n    timeout: 5000,\n    maxServerPingDelay: 10000,\n    networkEventTarget: null,\n};\n/** Centrifuge is a Centrifuge/Centrifugo bidirectional client. */\nclass Centrifuge extends events_1.default {\n    /** Constructs Centrifuge client. Call connect() method to start connecting. */\n    constructor(endpoint, options) {\n        super();\n        this._reconnectTimeout = null;\n        this._refreshTimeout = null;\n        this._serverPingTimeout = null;\n        this.state = types_1.State.Disconnected;\n        this._endpoint = endpoint;\n        this._emulation = false;\n        this._transports = [];\n        this._currentTransportIndex = 0;\n        this._triedAllTransports = false;\n        this._transportWasOpen = false;\n        this._transport = null;\n        this._transportClosed = true;\n        this._encoder = null;\n        this._decoder = null;\n        this._reconnecting = false;\n        this._reconnectTimeout = null;\n        this._reconnectAttempts = 0;\n        this._client = null;\n        this._session = '';\n        this._node = '';\n        this._subs = {};\n        this._serverSubs = {};\n        this._commandId = 0;\n        this._commands = [];\n        this._batching = false;\n        this._refreshRequired = false;\n        this._refreshTimeout = null;\n        this._callbacks = {};\n        this._token = undefined;\n        this._dispatchPromise = Promise.resolve();\n        this._serverPing = 0;\n        this._serverPingTimeout = null;\n        this._sendPong = false;\n        this._promises = {};\n        this._promiseId = 0;\n        this._debugEnabled = false;\n        this._config = Object.assign(Object.assign({}, defaults), options);\n        this._configure();\n        if (this._debugEnabled) {\n            this.on('state', (ctx) => {\n                this._debug('client state', ctx.oldState, '->', ctx.newState);\n            });\n            this.on('error', (ctx) => {\n                this._debug('client error', ctx);\n            });\n        }\n        else {\n            // Avoid unhandled exception in EventEmitter for non-set error handler.\n            this.on('error', function () { Function.prototype(); });\n        }\n    }\n    /** newSubscription allocates new Subscription to a channel. Since server only allows\n     * one subscription per channel per client this method throws if client already has\n     * channel subscription in internal registry.\n     * */\n    newSubscription(channel, options) {\n        if (this.getSubscription(channel) !== null) {\n            throw new Error('Subscription to the channel ' + channel + ' already exists');\n        }\n        const sub = new subscription_1.Subscription(this, channel, options);\n        this._subs[channel] = sub;\n        return sub;\n    }\n    /** getSubscription returns Subscription if it's registered in the internal\n     * registry or null. */\n    getSubscription(channel) {\n        return this._getSub(channel);\n    }\n    /** removeSubscription allows removing Subcription from the internal registry. Subscrption\n     * must be in unsubscribed state. */\n    removeSubscription(sub) {\n        if (!sub) {\n            return;\n        }\n        if (sub.state !== types_1.SubscriptionState.Unsubscribed) {\n            sub.unsubscribe();\n        }\n        this._removeSubscription(sub);\n    }\n    /** Get a map with all current client-side subscriptions. */\n    subscriptions() {\n        return this._subs;\n    }\n    /** ready returns a Promise which resolves upon client goes to Connected\n     * state and rejects in case of client goes to Disconnected or Failed state.\n     * Users can provide optional timeout in milliseconds. */\n    ready(timeout) {\n        if (this.state === types_1.State.Disconnected) {\n            return Promise.reject({ code: codes_1.errorCodes.clientDisconnected, message: 'client disconnected' });\n        }\n        if (this.state === types_1.State.Connected) {\n            return Promise.resolve();\n        }\n        return new Promise((res, rej) => {\n            const ctx = {\n                resolve: res,\n                reject: rej\n            };\n            if (timeout) {\n                ctx.timeout = setTimeout(function () {\n                    rej({ code: codes_1.errorCodes.timeout, message: 'timeout' });\n                }, timeout);\n            }\n            this._promises[this._nextPromiseId()] = ctx;\n        });\n    }\n    /** connect to a server. */\n    connect() {\n        if (this._isConnected()) {\n            this._debug('connect called when already connected');\n            return;\n        }\n        if (this._isConnecting()) {\n            this._debug('connect called when already connecting');\n            return;\n        }\n        this._reconnectAttempts = 0;\n        this._startConnecting();\n    }\n    /** disconnect from a server. */\n    disconnect() {\n        this._disconnect(codes_1.disconnectedCodes.disconnectCalled, 'disconnect called', false);\n    }\n    /** send asynchronous data to a server (without any response from a server\n     * expected, see rpc method if you need response). */\n    send(data) {\n        const cmd = {\n            send: {\n                data: data\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            const sent = self._transportSendCommands([cmd]); // can send message to server without id set\n            if (!sent) {\n                return Promise.reject(self._createErrorObject(codes_1.errorCodes.transportWriteError, 'transport write error'));\n            }\n            return Promise.resolve();\n        });\n    }\n    /** rpc to a server - i.e. a call which waits for a response with data. */\n    rpc(method, data) {\n        const cmd = {\n            rpc: {\n                method: method,\n                data: data\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function (reply) {\n                return {\n                    'data': reply.rpc.data\n                };\n            });\n        });\n    }\n    /** publish data to a channel. */\n    publish(channel, data) {\n        const cmd = {\n            publish: {\n                channel: channel,\n                data: data\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function () {\n                return {};\n            });\n        });\n    }\n    /** history for a channel. By default it does not return publications (only current\n     *  StreamPosition data) – provide an explicit limit > 0 to load publications.*/\n    history(channel, options) {\n        const cmd = {\n            history: this._getHistoryRequest(channel, options)\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function (reply) {\n                const result = reply.history;\n                const publications = [];\n                if (result.publications) {\n                    for (let i = 0; i < result.publications.length; i++) {\n                        publications.push(self._getPublicationContext(channel, result.publications[i]));\n                    }\n                }\n                return {\n                    'publications': publications,\n                    'epoch': result.epoch || '',\n                    'offset': result.offset || 0\n                };\n            });\n        });\n    }\n    /** presence for a channel. */\n    presence(channel) {\n        const cmd = {\n            presence: {\n                channel: channel\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function (reply) {\n                const clients = reply.presence.presence;\n                for (const clientId in clients) {\n                    if (clients.hasOwnProperty(clientId)) {\n                        const connInfo = clients[clientId]['conn_info'];\n                        const chanInfo = clients[clientId]['chan_info'];\n                        if (connInfo) {\n                            clients[clientId].connInfo = connInfo;\n                        }\n                        if (chanInfo) {\n                            clients[clientId].chanInfo = chanInfo;\n                        }\n                    }\n                }\n                return {\n                    'clients': clients\n                };\n            });\n        });\n    }\n    /** presence stats for a channel. */\n    presenceStats(channel) {\n        const cmd = {\n            'presence_stats': {\n                channel: channel\n            }\n        };\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._callPromise(cmd, function (reply) {\n                const result = reply.presence_stats;\n                return {\n                    'numUsers': result.num_users,\n                    'numClients': result.num_clients\n                };\n            });\n        });\n    }\n    /** start command batching (collect into temporary buffer without sending to a server)\n     * until stopBatching called.*/\n    startBatching() {\n        // start collecting messages without sending them to Centrifuge until flush\n        // method called\n        this._batching = true;\n    }\n    /** stop batching commands and flush collected commands to the\n     * network (all in one request/frame).*/\n    stopBatching() {\n        const self = this;\n        // Why so nested? Two levels here requred to deal with promise resolving queue.\n        // In Subscription case we wait 2 futures before sending data to connection.\n        // Otherwise _batching becomes false before batching decision has a chance to be executed.\n        Promise.resolve().then(function () {\n            Promise.resolve().then(function () {\n                self._batching = false;\n                self._flush();\n            });\n        });\n    }\n    _debug(...args) {\n        if (!this._debugEnabled) {\n            return;\n        }\n        (0, utils_1.log)('debug', args);\n    }\n    /** @internal */\n    _setFormat(format) {\n        if (this._formatOverride(format)) {\n            return;\n        }\n        if (format === 'protobuf') {\n            throw new Error('not implemented by JSON-only Centrifuge client, use client with Protobuf support');\n        }\n        this._encoder = new json_1.JsonEncoder();\n        this._decoder = new json_1.JsonDecoder();\n    }\n    /** @internal */\n    _formatOverride(_format) {\n        return false;\n    }\n    _configure() {\n        if (!('Promise' in globalThis)) {\n            throw new Error('Promise polyfill required');\n        }\n        if (!this._endpoint) {\n            throw new Error('endpoint configuration required');\n        }\n        if (this._config.protocol !== 'json' && this._config.protocol !== 'protobuf') {\n            throw new Error('unsupported protocol ' + this._config.protocol);\n        }\n        if (this._config.token !== null) {\n            this._token = this._config.token;\n        }\n        this._setFormat('json');\n        if (this._config.protocol === 'protobuf') {\n            this._setFormat('protobuf');\n        }\n        if (this._config.debug === true ||\n            (typeof localStorage !== 'undefined' && localStorage.getItem('centrifuge.debug'))) {\n            this._debugEnabled = true;\n        }\n        this._debug('config', this._config);\n        if (typeof this._endpoint === 'string') {\n            // Single address.\n        }\n        else if (typeof this._endpoint === 'object' && this._endpoint instanceof Array) {\n            this._transports = this._endpoint;\n            this._emulation = true;\n            for (const i in this._transports) {\n                const transportConfig = this._transports[i];\n                if (!transportConfig.endpoint || !transportConfig.transport) {\n                    throw new Error('malformed transport configuration');\n                }\n                const transportName = transportConfig.transport;\n                if (['websocket', 'http_stream', 'sse', 'sockjs', 'webtransport'].indexOf(transportName) < 0) {\n                    throw new Error('unsupported transport name: ' + transportName);\n                }\n            }\n        }\n        else {\n            throw new Error('unsupported url configuration type: only string or array of objects are supported');\n        }\n    }\n    _setState(newState) {\n        if (this.state !== newState) {\n            this._reconnecting = false;\n            const oldState = this.state;\n            this.state = newState;\n            this.emit('state', { newState, oldState });\n            return true;\n        }\n        return false;\n    }\n    _isDisconnected() {\n        return this.state === types_1.State.Disconnected;\n    }\n    _isConnecting() {\n        return this.state === types_1.State.Connecting;\n    }\n    _isConnected() {\n        return this.state === types_1.State.Connected;\n    }\n    _nextCommandId() {\n        return ++this._commandId;\n    }\n    _setNetworkEvents() {\n        let eventTarget = null;\n        if (this._config.networkEventTarget !== null) {\n            eventTarget = this._config.networkEventTarget;\n        }\n        else if (typeof globalThis.addEventListener !== 'undefined') {\n            eventTarget = globalThis;\n        }\n        if (eventTarget) {\n            eventTarget.addEventListener('offline', () => {\n                this._debug('offline event triggered');\n                if (this.state === types_1.State.Connected && this._transport && !this._transportClosed) {\n                    this._transportClosed = true;\n                    this._transport.close();\n                }\n            });\n            eventTarget.addEventListener('online', () => {\n                this._debug('online event triggered');\n                if (this.state === types_1.State.Connecting) {\n                    this._clearReconnectTimeout();\n                    this._startReconnecting();\n                }\n            });\n        }\n    }\n    _getReconnectDelay() {\n        const delay = (0, utils_1.backoff)(this._reconnectAttempts, this._config.minReconnectDelay, this._config.maxReconnectDelay);\n        this._reconnectAttempts += 1;\n        return delay;\n    }\n    _clearOutgoingRequests() {\n        // fire errbacks of registered outgoing calls.\n        for (const id in this._callbacks) {\n            if (this._callbacks.hasOwnProperty(id)) {\n                const callbacks = this._callbacks[id];\n                clearTimeout(callbacks.timeout);\n                const errback = callbacks.errback;\n                if (!errback) {\n                    continue;\n                }\n                errback({ error: this._createErrorObject(codes_1.errorCodes.connectionClosed, 'connection closed') });\n            }\n        }\n        this._callbacks = {};\n    }\n    _clearConnectedState() {\n        this._client = null;\n        this._clearServerPingTimeout();\n        this._clearRefreshTimeout();\n        // fire events for client-side subscriptions.\n        for (const channel in this._subs) {\n            if (!this._subs.hasOwnProperty(channel)) {\n                continue;\n            }\n            const sub = this._subs[channel];\n            if (sub.state === types_1.SubscriptionState.Subscribed) {\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n                sub._setSubscribing(codes_1.subscribingCodes.transportClosed, 'transport closed');\n            }\n        }\n        // fire events for server-side subscriptions.\n        for (const channel in this._serverSubs) {\n            if (this._serverSubs.hasOwnProperty(channel)) {\n                this.emit('subscribing', { channel: channel });\n            }\n        }\n    }\n    _handleWriteError(commands) {\n        for (const command of commands) {\n            const id = command.id;\n            if (!(id in this._callbacks)) {\n                continue;\n            }\n            const callbacks = this._callbacks[id];\n            clearTimeout(this._callbacks[id].timeout);\n            delete this._callbacks[id];\n            const errback = callbacks.errback;\n            errback({ error: this._createErrorObject(codes_1.errorCodes.transportWriteError, 'transport write error') });\n        }\n    }\n    _transportSendCommands(commands) {\n        if (!commands.length) {\n            return true;\n        }\n        if (!this._transport) {\n            return false;\n        }\n        try {\n            this._transport.send(this._encoder.encodeCommands(commands), this._session, this._node);\n        }\n        catch (e) {\n            this._debug('error writing commands', e);\n            this._handleWriteError(commands);\n            return false;\n        }\n        return true;\n    }\n    _initializeTransport() {\n        let websocket;\n        if (this._config.websocket !== null) {\n            websocket = this._config.websocket;\n        }\n        else {\n            if (!(typeof globalThis.WebSocket !== 'function' && typeof globalThis.WebSocket !== 'object')) {\n                websocket = globalThis.WebSocket;\n            }\n        }\n        let sockjs = null;\n        if (this._config.sockjs !== null) {\n            sockjs = this._config.sockjs;\n        }\n        else {\n            if (typeof globalThis.SockJS !== 'undefined') {\n                sockjs = globalThis.SockJS;\n            }\n        }\n        let eventsource = null;\n        if (this._config.eventsource !== null) {\n            eventsource = this._config.eventsource;\n        }\n        else {\n            if (typeof globalThis.EventSource !== 'undefined') {\n                eventsource = globalThis.EventSource;\n            }\n        }\n        let fetchFunc = null;\n        if (this._config.fetch !== null) {\n            fetchFunc = this._config.fetch;\n        }\n        else {\n            if (typeof globalThis.fetch !== 'undefined') {\n                fetchFunc = globalThis.fetch;\n            }\n        }\n        let readableStream = null;\n        if (this._config.readableStream !== null) {\n            readableStream = this._config.readableStream;\n        }\n        else {\n            if (typeof globalThis.ReadableStream !== 'undefined') {\n                readableStream = globalThis.ReadableStream;\n            }\n        }\n        if (!this._emulation) {\n            if ((0, utils_1.startsWith)(this._endpoint, 'http')) {\n                throw new Error('Provide explicit transport endpoints configuration in case of using HTTP (i.e. using array of TransportEndpoint instead of a single string), or use ws(s):// scheme in an endpoint if you aimed using WebSocket transport');\n            }\n            else {\n                this._debug('client will use websocket');\n                this._transport = new transport_websocket_1.WebsocketTransport(this._endpoint, {\n                    websocket: websocket\n                });\n                if (!this._transport.supported()) {\n                    throw new Error('WebSocket not available');\n                }\n            }\n        }\n        else {\n            if (this._currentTransportIndex >= this._transports.length) {\n                this._triedAllTransports = true;\n                this._currentTransportIndex = 0;\n            }\n            let count = 0;\n            while (true) {\n                if (count >= this._transports.length) {\n                    throw new Error('no supported transport found');\n                }\n                const transportConfig = this._transports[this._currentTransportIndex];\n                const transportName = transportConfig.transport;\n                const transportEndpoint = transportConfig.endpoint;\n                if (transportName === 'websocket') {\n                    this._debug('trying websocket transport');\n                    this._transport = new transport_websocket_1.WebsocketTransport(transportEndpoint, {\n                        websocket: websocket\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('websocket transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else if (transportName === 'webtransport') {\n                    this._debug('trying webtransport transport');\n                    this._transport = new transport_webtransport_1.WebtransportTransport(transportEndpoint, {\n                        webtransport: globalThis.WebTransport,\n                        decoder: this._decoder,\n                        encoder: this._encoder\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('webtransport transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else if (transportName === 'http_stream') {\n                    this._debug('trying http_stream transport');\n                    this._transport = new transport_http_stream_1.HttpStreamTransport(transportEndpoint, {\n                        fetch: fetchFunc,\n                        readableStream: readableStream,\n                        emulationEndpoint: this._config.emulationEndpoint,\n                        decoder: this._decoder,\n                        encoder: this._encoder\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('http_stream transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else if (transportName === 'sse') {\n                    this._debug('trying sse transport');\n                    this._transport = new transport_sse_1.SseTransport(transportEndpoint, {\n                        eventsource: eventsource,\n                        fetch: fetchFunc,\n                        emulationEndpoint: this._config.emulationEndpoint,\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('sse transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else if (transportName === 'sockjs') {\n                    this._debug('trying sockjs');\n                    this._transport = new transport_sockjs_1.SockjsTransport(transportEndpoint, {\n                        sockjs: sockjs,\n                        sockjsOptions: this._config.sockjsOptions\n                    });\n                    if (!this._transport.supported()) {\n                        this._debug('sockjs transport not available');\n                        this._currentTransportIndex++;\n                        count++;\n                        continue;\n                    }\n                }\n                else {\n                    throw new Error('unknown transport ' + transportName);\n                }\n                break;\n            }\n        }\n        const self = this;\n        let transportName;\n        let wasOpen = false;\n        let optimistic = true;\n        if (this._transport.name() === 'sse') {\n            // Avoid using optimistic subscriptions with SSE/EventSource as we are sending\n            // initial data in URL params. URL is recommended to be 2048 chars max – so adding\n            // subscription data may be risky.\n            optimistic = false;\n        }\n        const initialCommands = [];\n        if (this._transport.emulation()) {\n            const connectCommand = self._sendConnect(true);\n            initialCommands.push(connectCommand);\n            if (optimistic) {\n                const subscribeCommands = self._sendSubscribeCommands(true, true);\n                for (const i in subscribeCommands) {\n                    initialCommands.push(subscribeCommands[i]);\n                }\n            }\n        }\n        const initialData = this._encoder.encodeCommands(initialCommands);\n        this._transport.initialize(this._config.protocol, {\n            onOpen: function () {\n                wasOpen = true;\n                transportName = self._transport.subName();\n                self._debug(transportName, 'transport open');\n                self._transportWasOpen = true;\n                self._transportClosed = false;\n                if (self._transport.emulation()) {\n                    return;\n                }\n                self.startBatching();\n                self._sendConnect(false);\n                if (optimistic) {\n                    self._sendSubscribeCommands(true, false);\n                }\n                self.stopBatching();\n            },\n            onError: function (e) {\n                self._debug('transport level error', e);\n            },\n            onClose: function (closeEvent) {\n                self._debug(self._transport.name(), 'transport closed');\n                self._transportClosed = true;\n                let reason = 'connection closed';\n                let needReconnect = true;\n                let code = 0;\n                if (closeEvent && 'code' in closeEvent && closeEvent.code) {\n                    code = closeEvent.code;\n                }\n                if (closeEvent && closeEvent.reason) {\n                    try {\n                        const advice = JSON.parse(closeEvent.reason);\n                        reason = advice.reason;\n                        needReconnect = advice.reconnect;\n                    }\n                    catch (e) {\n                        reason = closeEvent.reason;\n                        if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n                            needReconnect = false;\n                        }\n                    }\n                }\n                if (code < 3000) {\n                    if (code === 1009) {\n                        code = codes_1.disconnectedCodes.messageSizeLimit;\n                        reason = 'message size limit exceeded';\n                        needReconnect = false;\n                    }\n                    else {\n                        code = codes_1.connectingCodes.transportClosed;\n                        reason = 'transport closed';\n                    }\n                    if (self._emulation && !self._transportWasOpen) {\n                        self._currentTransportIndex++;\n                        if (self._currentTransportIndex >= self._transports.length) {\n                            self._triedAllTransports = true;\n                            self._currentTransportIndex = 0;\n                        }\n                    }\n                }\n                else {\n                    // Codes >= 3000 are sent from a server application level.\n                    self._transportWasOpen = true;\n                }\n                let isInitialHandshake = false;\n                if (self._emulation && !self._transportWasOpen && !self._triedAllTransports) {\n                    isInitialHandshake = true;\n                }\n                if (self._isConnecting() && !wasOpen) {\n                    self.emit('error', {\n                        type: 'transport',\n                        error: {\n                            code: codes_1.errorCodes.transportClosed,\n                            message: 'transport closed'\n                        },\n                        transport: self._transport.name()\n                    });\n                }\n                self._disconnect(code, reason, needReconnect);\n                if (self._isConnecting()) {\n                    let delay = self._getReconnectDelay();\n                    if (isInitialHandshake) {\n                        delay = 0;\n                    }\n                    self._debug('reconnect after ' + delay + ' milliseconds');\n                    self._reconnecting = false;\n                    self._reconnectTimeout = setTimeout(() => {\n                        self._startReconnecting();\n                    }, delay);\n                }\n            },\n            onMessage: function (data) {\n                self._dataReceived(data);\n            }\n        }, initialData);\n    }\n    _sendConnect(skipSending) {\n        const connectCommand = this._constructConnectCommand();\n        const self = this;\n        this._call(connectCommand, skipSending).then(resolveCtx => {\n            // @ts-ignore = improve later.\n            const result = resolveCtx.reply.connect;\n            self._connectResponse(result);\n            // @ts-ignore - improve later.\n            if (resolveCtx.next) {\n                // @ts-ignore - improve later.\n                resolveCtx.next();\n            }\n        }, rejectCtx => {\n            self._connectError(rejectCtx.error);\n            if (rejectCtx.next) {\n                rejectCtx.next();\n            }\n        });\n        return connectCommand;\n    }\n    _startReconnecting() {\n        if (!this._isConnecting() || this._reconnecting) {\n            return;\n        }\n        this._reconnecting = true;\n        const needTokenRefresh = this._refreshRequired || (!this._token && this._config.getToken !== null);\n        if (!needTokenRefresh) {\n            this._initializeTransport();\n            return;\n        }\n        const self = this;\n        this._getToken().then(function (token) {\n            if (!self._isConnecting()) {\n                return;\n            }\n            if (!token) {\n                self._failUnauthorized();\n                return;\n            }\n            self._token = token;\n            self._debug('connection token refreshed');\n            self._initializeTransport();\n        }).catch(function (e) {\n            if (!self._isConnecting()) {\n                return;\n            }\n            self.emit('error', {\n                'type': 'connectToken',\n                'error': {\n                    code: codes_1.errorCodes.clientConnectToken,\n                    message: e !== undefined ? e.toString() : ''\n                }\n            });\n            const delay = self._getReconnectDelay();\n            self._debug('error on connection token refresh, reconnect after ' + delay + ' milliseconds', e);\n            self._reconnecting = false;\n            self._reconnectTimeout = setTimeout(() => {\n                self._startReconnecting();\n            }, delay);\n        });\n    }\n    _connectError(err) {\n        if (this.state !== types_1.State.Connecting) {\n            return;\n        }\n        if (err.code === 109) { // token expired.\n            // next connect attempt will try to refresh token.\n            this._refreshRequired = true;\n        }\n        if (err.code < 100 || err.temporary === true || err.code === 109) {\n            this.emit('error', {\n                'type': 'connect',\n                'error': err\n            });\n            // Not yet connected, closing transport is enough.\n            if (this._transport && !this._transportClosed) {\n                this._transportClosed = true;\n                this._transport.close();\n            }\n        }\n        else {\n            this._disconnect(err.code, err.message, false);\n        }\n    }\n    _constructConnectCommand() {\n        const req = {};\n        if (this._token) {\n            req.token = this._token;\n        }\n        if (this._config.data) {\n            req.data = this._config.data;\n        }\n        if (this._config.name) {\n            req.name = this._config.name;\n        }\n        if (this._config.version) {\n            req.version = this._config.version;\n        }\n        const subs = {};\n        let hasSubs = false;\n        for (const channel in this._serverSubs) {\n            if (this._serverSubs.hasOwnProperty(channel) && this._serverSubs[channel].recoverable) {\n                hasSubs = true;\n                const sub = {\n                    'recover': true\n                };\n                if (this._serverSubs[channel].offset) {\n                    sub['offset'] = this._serverSubs[channel].offset;\n                }\n                if (this._serverSubs[channel].epoch) {\n                    sub['epoch'] = this._serverSubs[channel].epoch;\n                }\n                subs[channel] = sub;\n            }\n        }\n        if (hasSubs) {\n            req.subs = subs;\n        }\n        return {\n            connect: req\n        };\n    }\n    _getHistoryRequest(channel, options) {\n        const req = {\n            channel: channel\n        };\n        if (options !== undefined) {\n            if (options.since) {\n                req.since = {\n                    offset: options.since.offset\n                };\n                if (options.since.epoch) {\n                    req.since.epoch = options.since.epoch;\n                }\n            }\n            if (options.limit !== undefined) {\n                req.limit = options.limit;\n            }\n            if (options.reverse === true) {\n                req.reverse = true;\n            }\n        }\n        return req;\n    }\n    _methodCall() {\n        if (this._isConnected()) {\n            return Promise.resolve();\n        }\n        return new Promise((res, rej) => {\n            const timeout = setTimeout(function () {\n                rej({ code: codes_1.errorCodes.timeout, message: 'timeout' });\n            }, this._config.timeout);\n            this._promises[this._nextPromiseId()] = {\n                timeout: timeout,\n                resolve: res,\n                reject: rej\n            };\n        });\n    }\n    _callPromise(cmd, resultCB) {\n        return new Promise((resolve, reject) => {\n            this._call(cmd, false).then(resolveCtx => {\n                // @ts-ignore - improve later.\n                resolve(resultCB(resolveCtx.reply));\n                // @ts-ignore - improve later.\n                if (resolveCtx.next) {\n                    // @ts-ignore - improve later.\n                    resolveCtx.next();\n                }\n            }, rejectCtx => {\n                reject(rejectCtx.error);\n                if (rejectCtx.next) {\n                    rejectCtx.next();\n                }\n            });\n        });\n    }\n    _dataReceived(data) {\n        if (this._serverPing > 0) {\n            this._waitServerPing();\n        }\n        const replies = this._decoder.decodeReplies(data);\n        // We have to guarantee order of events in replies processing - i.e. start processing\n        // next reply only when we finished processing of current one. Without syncing things in\n        // this way we could get wrong publication events order as reply promises resolve\n        // on next loop tick so for loop continues before we finished emitting all reply events.\n        this._dispatchPromise = this._dispatchPromise.then(() => {\n            let finishDispatch;\n            this._dispatchPromise = new Promise(resolve => {\n                finishDispatch = resolve;\n            });\n            this._dispatchSynchronized(replies, finishDispatch);\n        });\n    }\n    _dispatchSynchronized(replies, finishDispatch) {\n        let p = Promise.resolve();\n        for (const i in replies) {\n            if (replies.hasOwnProperty(i)) {\n                p = p.then(() => {\n                    return this._dispatchReply(replies[i]);\n                });\n            }\n        }\n        p = p.then(() => {\n            finishDispatch();\n        });\n    }\n    _dispatchReply(reply) {\n        let next;\n        const p = new Promise(resolve => {\n            next = resolve;\n        });\n        if (reply === undefined || reply === null) {\n            this._debug('dispatch: got undefined or null reply');\n            next();\n            return p;\n        }\n        const id = reply.id;\n        if (id && id > 0) {\n            this._handleReply(reply, next);\n        }\n        else {\n            if (!reply.push) {\n                this._handleServerPing(next);\n            }\n            else {\n                this._handlePush(reply.push, next);\n            }\n        }\n        return p;\n    }\n    _call(cmd, skipSending) {\n        return new Promise((resolve, reject) => {\n            cmd.id = this._nextCommandId();\n            this._registerCall(cmd.id, resolve, reject);\n            if (!skipSending) {\n                this._addCommand(cmd);\n            }\n        });\n    }\n    _startConnecting() {\n        this._debug('start connecting');\n        if (this._setState(types_1.State.Connecting)) {\n            this.emit('connecting', { code: codes_1.connectingCodes.connectCalled, reason: 'connect called' });\n        }\n        this._client = null;\n        this._startReconnecting();\n    }\n    _disconnect(code, reason, reconnect) {\n        if (this._isDisconnected()) {\n            return;\n        }\n        const previousState = this.state;\n        const ctx = {\n            code: code,\n            reason: reason\n        };\n        let needEvent = false;\n        if (reconnect) {\n            needEvent = this._setState(types_1.State.Connecting);\n        }\n        else {\n            needEvent = this._setState(types_1.State.Disconnected);\n            this._rejectPromises({ code: codes_1.errorCodes.clientDisconnected, message: 'disconnected' });\n        }\n        this._clearOutgoingRequests();\n        if (previousState === types_1.State.Connecting) {\n            this._clearReconnectTimeout();\n        }\n        if (previousState === types_1.State.Connected) {\n            this._clearConnectedState();\n        }\n        if (needEvent) {\n            if (this._isConnecting()) {\n                this.emit('connecting', ctx);\n            }\n            else {\n                this.emit('disconnected', ctx);\n            }\n        }\n        if (this._transport && !this._transportClosed) {\n            this._transportClosed = true;\n            this._transport.close();\n        }\n    }\n    _failUnauthorized() {\n        this._disconnect(codes_1.disconnectedCodes.unauthorized, 'unauthorized', false);\n    }\n    _getToken() {\n        this._debug('get connection token');\n        if (!this._config.getToken) {\n            throw new Error('provide a function to get connection token');\n        }\n        return this._config.getToken({});\n    }\n    _refresh() {\n        const clientId = this._client;\n        const self = this;\n        this._getToken().then(function (token) {\n            if (clientId !== self._client) {\n                return;\n            }\n            if (!token) {\n                self._failUnauthorized();\n                return;\n            }\n            self._token = token;\n            self._debug('connection token refreshed');\n            if (!self._isConnected()) {\n                return;\n            }\n            const cmd = {\n                refresh: { token: self._token }\n            };\n            self._call(cmd, false).then(resolveCtx => {\n                // @ts-ignore - improve later.\n                const result = resolveCtx.reply.refresh;\n                self._refreshResponse(result);\n                // @ts-ignore - improve later.\n                if (resolveCtx.next) {\n                    // @ts-ignore - improve later.\n                    resolveCtx.next();\n                }\n            }, rejectCtx => {\n                self._refreshError(rejectCtx.error);\n                if (rejectCtx.next) {\n                    rejectCtx.next();\n                }\n            });\n        }).catch(function (e) {\n            self.emit('error', {\n                type: 'refreshToken',\n                error: {\n                    code: codes_1.errorCodes.clientRefreshToken,\n                    message: e !== undefined ? e.toString() : ''\n                }\n            });\n            self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n        });\n    }\n    _refreshError(err) {\n        if (err.code < 100 || err.temporary === true) {\n            this.emit('error', {\n                type: 'refresh',\n                error: err\n            });\n            this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n        }\n        else {\n            this._disconnect(err.code, err.message, false);\n        }\n    }\n    _getRefreshRetryDelay() {\n        return (0, utils_1.backoff)(0, 5000, 10000);\n    }\n    _refreshResponse(result) {\n        if (this._refreshTimeout) {\n            clearTimeout(this._refreshTimeout);\n            this._refreshTimeout = null;\n        }\n        if (result.expires) {\n            this._client = result.client;\n            this._refreshTimeout = setTimeout(() => this._refresh(), (0, utils_1.ttlMilliseconds)(result.ttl));\n        }\n    }\n    _removeSubscription(sub) {\n        if (sub === null) {\n            return;\n        }\n        delete this._subs[sub.channel];\n    }\n    _unsubscribe(sub) {\n        if (!this._isConnected()) {\n            return;\n        }\n        const req = {\n            channel: sub.channel\n        };\n        const cmd = { unsubscribe: req };\n        const self = this;\n        this._call(cmd, false).then(resolveCtx => {\n            // @ts-ignore - improve later.\n            if (resolveCtx.next) {\n                // @ts-ignore - improve later.\n                resolveCtx.next();\n            }\n        }, rejectCtx => {\n            if (rejectCtx.next) {\n                rejectCtx.next();\n            }\n            self._disconnect(codes_1.connectingCodes.unsubscribeError, 'unsubscribe error', true);\n        });\n    }\n    _getSub(channel) {\n        const sub = this._subs[channel];\n        if (!sub) {\n            return null;\n        }\n        return sub;\n    }\n    _isServerSub(channel) {\n        return this._serverSubs[channel] !== undefined;\n    }\n    _sendSubscribeCommands(optimistic, skipSending) {\n        const commands = [];\n        for (const channel in this._subs) {\n            if (!this._subs.hasOwnProperty(channel)) {\n                continue;\n            }\n            const sub = this._subs[channel];\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            if (sub._inflight === true) {\n                continue;\n            }\n            if (sub.state === types_1.SubscriptionState.Subscribing) {\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n                const cmd = sub._subscribe(optimistic, skipSending);\n                if (cmd) {\n                    commands.push(cmd);\n                }\n            }\n        }\n        return commands;\n    }\n    _connectResponse(result) {\n        this._transportWasOpen = true;\n        this._reconnectAttempts = 0;\n        this._refreshRequired = false;\n        if (this._isConnected()) {\n            return;\n        }\n        this._client = result.client;\n        this._setState(types_1.State.Connected);\n        this._setNetworkEvents();\n        if (this._refreshTimeout) {\n            clearTimeout(this._refreshTimeout);\n        }\n        if (result.expires) {\n            this._refreshTimeout = setTimeout(() => this._refresh(), (0, utils_1.ttlMilliseconds)(result.ttl));\n        }\n        this._session = result.session;\n        this._node = result.node;\n        this.startBatching();\n        this._sendSubscribeCommands(false, false);\n        this.stopBatching();\n        const ctx = {\n            client: result.client,\n            transport: this._transport.subName()\n        };\n        if (result.data) {\n            ctx.data = result.data;\n        }\n        this.emit('connected', ctx);\n        this._resolvePromises();\n        this._processServerSubs(result.subs || {});\n        if (result.ping && result.ping > 0) {\n            this._serverPing = result.ping * 1000;\n            this._sendPong = result.pong === true;\n            this._waitServerPing();\n        }\n        else {\n            this._serverPing = 0;\n        }\n    }\n    _processServerSubs(subs) {\n        for (const channel in subs) {\n            if (!subs.hasOwnProperty(channel)) {\n                continue;\n            }\n            const sub = subs[channel];\n            this._serverSubs[channel] = {\n                'offset': sub.offset,\n                'epoch': sub.epoch,\n                'recoverable': sub.recoverable || false\n            };\n            const subCtx = this._getSubscribeContext(channel, sub);\n            this.emit('subscribed', subCtx);\n        }\n        for (const channel in subs) {\n            if (!subs.hasOwnProperty(channel)) {\n                continue;\n            }\n            const sub = subs[channel];\n            if (sub.recovered) {\n                const pubs = sub.publications;\n                if (pubs && pubs.length > 0) {\n                    for (const i in pubs) {\n                        if (pubs.hasOwnProperty(i)) {\n                            this._handlePublication(channel, pubs[i]);\n                        }\n                    }\n                }\n            }\n        }\n        for (const channel in this._serverSubs) {\n            if (!this._serverSubs.hasOwnProperty(channel)) {\n                continue;\n            }\n            if (!subs[channel]) {\n                this.emit('unsubscribed', { channel: channel });\n                delete this._serverSubs[channel];\n            }\n        }\n    }\n    _clearRefreshTimeout() {\n        if (this._refreshTimeout !== null) {\n            clearTimeout(this._refreshTimeout);\n            this._refreshTimeout = null;\n        }\n    }\n    _clearReconnectTimeout() {\n        if (this._reconnectTimeout !== null) {\n            clearTimeout(this._reconnectTimeout);\n            this._reconnectTimeout = null;\n        }\n    }\n    _clearServerPingTimeout() {\n        if (this._serverPingTimeout !== null) {\n            clearTimeout(this._serverPingTimeout);\n            this._serverPingTimeout = null;\n        }\n    }\n    _waitServerPing() {\n        if (this._config.maxServerPingDelay === 0) {\n            return;\n        }\n        if (!this._isConnected()) {\n            return;\n        }\n        this._clearServerPingTimeout();\n        this._serverPingTimeout = setTimeout(() => {\n            if (!this._isConnected()) {\n                return;\n            }\n            this._disconnect(codes_1.connectingCodes.noPing, 'no ping', true);\n        }, this._serverPing + this._config.maxServerPingDelay);\n    }\n    _getSubscribeContext(channel, result) {\n        const ctx = {\n            channel: channel,\n            positioned: false,\n            recoverable: false,\n            wasRecovering: false,\n            recovered: false\n        };\n        if (result.recovered) {\n            ctx.recovered = true;\n        }\n        if (result.positioned) {\n            ctx.positioned = true;\n        }\n        if (result.recoverable) {\n            ctx.recoverable = true;\n        }\n        if (result.was_recovering) {\n            ctx.wasRecovering = true;\n        }\n        let epoch = '';\n        if ('epoch' in result) {\n            epoch = result.epoch;\n        }\n        let offset = 0;\n        if ('offset' in result) {\n            offset = result.offset;\n        }\n        if (ctx.positioned || ctx.recoverable) {\n            ctx.streamPosition = {\n                'offset': offset,\n                'epoch': epoch\n            };\n        }\n        if (result.data) {\n            ctx.data = result.data;\n        }\n        return ctx;\n    }\n    _handleReply(reply, next) {\n        const id = reply.id;\n        if (!(id in this._callbacks)) {\n            next();\n            return;\n        }\n        const callbacks = this._callbacks[id];\n        clearTimeout(this._callbacks[id].timeout);\n        delete this._callbacks[id];\n        if (!(0, utils_1.errorExists)(reply)) {\n            const callback = callbacks.callback;\n            if (!callback) {\n                return;\n            }\n            callback({ reply, next });\n        }\n        else {\n            const errback = callbacks.errback;\n            if (!errback) {\n                next();\n                return;\n            }\n            const error = reply.error;\n            errback({ error, next });\n        }\n    }\n    _handleJoin(channel, join) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n            if (this._isServerSub(channel)) {\n                const ctx = { channel: channel, info: this._getJoinLeaveContext(join.info) };\n                this.emit('join', ctx);\n            }\n            return;\n        }\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        sub._handleJoin(join);\n    }\n    _handleLeave(channel, leave) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n            if (this._isServerSub(channel)) {\n                const ctx = { channel: channel, info: this._getJoinLeaveContext(leave.info) };\n                this.emit('leave', ctx);\n            }\n            return;\n        }\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        sub._handleLeave(leave);\n    }\n    _handleUnsubscribe(channel, unsubscribe) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n            if (this._isServerSub(channel)) {\n                delete this._serverSubs[channel];\n                this.emit('unsubscribed', { channel: channel });\n            }\n            return;\n        }\n        if (unsubscribe.code < 2500) {\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            sub._setUnsubscribed(unsubscribe.code, unsubscribe.reason, false);\n        }\n        else {\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            sub._setSubscribing(unsubscribe.code, unsubscribe.reason);\n        }\n    }\n    _handleSubscribe(channel, sub) {\n        this._serverSubs[channel] = {\n            'offset': sub.offset,\n            'epoch': sub.epoch,\n            'recoverable': sub.recoverable || false\n        };\n        this.emit('subscribed', this._getSubscribeContext(channel, sub));\n    }\n    _handleDisconnect(disconnect) {\n        const code = disconnect.code;\n        let reconnect = true;\n        if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n            reconnect = false;\n        }\n        this._disconnect(code, disconnect.reason, reconnect);\n    }\n    _getPublicationContext(channel, pub) {\n        const ctx = {\n            channel: channel,\n            data: pub.data\n        };\n        if (pub.offset) {\n            ctx.offset = pub.offset;\n        }\n        if (pub.info) {\n            ctx.info = this._getJoinLeaveContext(pub.info);\n        }\n        if (pub.tags) {\n            ctx.tags = pub.tags;\n        }\n        return ctx;\n    }\n    _getJoinLeaveContext(clientInfo) {\n        const info = {\n            client: clientInfo.client,\n            user: clientInfo.user\n        };\n        if (clientInfo.conn_info) {\n            info.connInfo = clientInfo.conn_info;\n        }\n        if (clientInfo.chan_info) {\n            info.chanInfo = clientInfo.chan_info;\n        }\n        return info;\n    }\n    _handlePublication(channel, pub) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n            if (this._isServerSub(channel)) {\n                const ctx = this._getPublicationContext(channel, pub);\n                this.emit('publication', ctx);\n                if (pub.offset !== undefined) {\n                    this._serverSubs[channel].offset = pub.offset;\n                }\n            }\n            return;\n        }\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        sub._handlePublication(pub);\n    }\n    _handleMessage(message) {\n        this.emit('message', { data: message.data });\n    }\n    _handleServerPing(next) {\n        if (this._sendPong) {\n            const cmd = {};\n            this._transportSendCommands([cmd]);\n        }\n        next();\n    }\n    _handlePush(data, next) {\n        const channel = data.channel;\n        if (data.pub) {\n            this._handlePublication(channel, data.pub);\n        }\n        else if (data.message) {\n            this._handleMessage(data.message);\n        }\n        else if (data.join) {\n            this._handleJoin(channel, data.join);\n        }\n        else if (data.leave) {\n            this._handleLeave(channel, data.leave);\n        }\n        else if (data.unsubscribe) {\n            this._handleUnsubscribe(channel, data.unsubscribe);\n        }\n        else if (data.subscribe) {\n            this._handleSubscribe(channel, data.subscribe);\n        }\n        else if (data.disconnect) {\n            this._handleDisconnect(data.disconnect);\n        }\n        next();\n    }\n    _flush() {\n        const commands = this._commands.slice(0);\n        this._commands = [];\n        this._transportSendCommands(commands);\n    }\n    _createErrorObject(code, message, temporary) {\n        const errObject = {\n            code: code,\n            message: message\n        };\n        if (temporary) {\n            errObject.temporary = true;\n        }\n        return errObject;\n    }\n    _registerCall(id, callback, errback) {\n        this._callbacks[id] = {\n            callback: callback,\n            errback: errback,\n            timeout: null\n        };\n        this._callbacks[id].timeout = setTimeout(() => {\n            delete this._callbacks[id];\n            if ((0, utils_1.isFunction)(errback)) {\n                errback({ error: this._createErrorObject(codes_1.errorCodes.timeout, 'timeout') });\n            }\n        }, this._config.timeout);\n    }\n    _addCommand(command) {\n        if (this._batching) {\n            this._commands.push(command);\n        }\n        else {\n            this._transportSendCommands([command]);\n        }\n    }\n    _nextPromiseId() {\n        return ++this._promiseId;\n    }\n    _resolvePromises() {\n        for (const id in this._promises) {\n            if (this._promises[id].timeout) {\n                clearTimeout(this._promises[id].timeout);\n            }\n            this._promises[id].resolve();\n            delete this._promises[id];\n        }\n    }\n    _rejectPromises(err) {\n        for (const id in this._promises) {\n            if (this._promises[id].timeout) {\n                clearTimeout(this._promises[id].timeout);\n            }\n            this._promises[id].reject(err);\n            delete this._promises[id];\n        }\n    }\n}\nexports.Centrifuge = Centrifuge;\nCentrifuge.SubscriptionState = types_1.SubscriptionState;\nCentrifuge.State = types_1.State;\n//# sourceMappingURL=centrifuge.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscription = void 0;\nconst events_1 = __importDefault(require(\"events\"));\nconst codes_1 = require(\"./codes\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\n/** Subscription to a channel */\nclass Subscription extends events_1.default {\n    /** Subscription constructor should not be used directly, create subscriptions using Client method. */\n    constructor(centrifuge, channel, options) {\n        super();\n        this._resubscribeTimeout = null;\n        this._refreshTimeout = null;\n        this.channel = channel;\n        this.state = types_1.SubscriptionState.Unsubscribed;\n        this._centrifuge = centrifuge;\n        this._token = null;\n        this._getToken = null;\n        this._data = null;\n        this._recover = false;\n        this._offset = null;\n        this._epoch = null;\n        this._recoverable = false;\n        this._positioned = false;\n        this._joinLeave = false;\n        this._minResubscribeDelay = 500;\n        this._maxResubscribeDelay = 20000;\n        this._resubscribeTimeout = null;\n        this._resubscribeAttempts = 0;\n        this._promises = {};\n        this._promiseId = 0;\n        this._inflight = false;\n        this._refreshTimeout = null;\n        this._setOptions(options);\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        if (this._centrifuge._debugEnabled) {\n            this.on('state', (ctx) => {\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n                this._centrifuge._debug('subscription state', channel, ctx.oldState, '->', ctx.newState);\n            });\n            this.on('error', (ctx) => {\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n                this._centrifuge._debug('subscription error', channel, ctx);\n            });\n        }\n        else {\n            // Avoid unhandled exception in EventEmitter for non-set error handler.\n            this.on('error', function () { Function.prototype(); });\n        }\n    }\n    /** ready returns a Promise which resolves upon subscription goes to Subscribed\n     * state and rejects in case of subscription goes to Unsubscribed state.\n     * Optional timeout can be passed.*/\n    ready(timeout) {\n        if (this.state === types_1.SubscriptionState.Unsubscribed) {\n            return Promise.reject({ code: codes_1.errorCodes.subscriptionUnsubscribed, message: this.state });\n        }\n        if (this.state === types_1.SubscriptionState.Subscribed) {\n            return Promise.resolve();\n        }\n        return new Promise((res, rej) => {\n            const ctx = {\n                resolve: res,\n                reject: rej\n            };\n            if (timeout) {\n                ctx.timeout = setTimeout(function () {\n                    rej({ code: codes_1.errorCodes.timeout, message: 'timeout' });\n                }, timeout);\n            }\n            this._promises[this._nextPromiseId()] = ctx;\n        });\n    }\n    /** subscribe to a channel.*/\n    subscribe() {\n        if (this._isSubscribed()) {\n            return;\n        }\n        this._resubscribeAttempts = 0;\n        this._setSubscribing(codes_1.subscribingCodes.subscribeCalled, 'subscribe called');\n    }\n    /** unsubscribe from a channel, keeping position state.*/\n    unsubscribe() {\n        this._setUnsubscribed(codes_1.unsubscribedCodes.unsubscribeCalled, 'unsubscribe called', true);\n    }\n    /** publish data to a channel.*/\n    publish(data) {\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._centrifuge.publish(self.channel, data);\n        });\n    }\n    /** get online presence for a channel.*/\n    presence() {\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._centrifuge.presence(self.channel);\n        });\n    }\n    /** presence stats for a channel (num clients and unique users).*/\n    presenceStats() {\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._centrifuge.presenceStats(self.channel);\n        });\n    }\n    /** history for a channel. By default it does not return publications (only current\n     *  StreamPosition data) – provide an explicit limit > 0 to load publications.*/\n    history(opts) {\n        const self = this;\n        return this._methodCall().then(function () {\n            return self._centrifuge.history(self.channel, opts);\n        });\n    }\n    _methodCall() {\n        if (this._isSubscribed()) {\n            return Promise.resolve();\n        }\n        if (this._isUnsubscribed()) {\n            return Promise.reject({ code: codes_1.errorCodes.subscriptionUnsubscribed, message: this.state });\n        }\n        return new Promise((res, rej) => {\n            const timeout = setTimeout(function () {\n                rej({ code: codes_1.errorCodes.timeout, message: 'timeout' });\n                // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            }, this._centrifuge._config.timeout);\n            this._promises[this._nextPromiseId()] = {\n                timeout: timeout,\n                resolve: res,\n                reject: rej\n            };\n        });\n    }\n    _nextPromiseId() {\n        return ++this._promiseId;\n    }\n    _needRecover() {\n        return this._recover === true;\n    }\n    _isUnsubscribed() {\n        return this.state === types_1.SubscriptionState.Unsubscribed;\n    }\n    _isSubscribing() {\n        return this.state === types_1.SubscriptionState.Subscribing;\n    }\n    _isSubscribed() {\n        return this.state === types_1.SubscriptionState.Subscribed;\n    }\n    _setState(newState) {\n        if (this.state !== newState) {\n            const oldState = this.state;\n            this.state = newState;\n            this.emit('state', { newState, oldState, channel: this.channel });\n            return true;\n        }\n        return false;\n    }\n    _usesToken() {\n        return this._token !== null || this._getToken !== null;\n    }\n    _clearSubscribingState() {\n        this._resubscribeAttempts = 0;\n        this._clearResubscribeTimeout();\n    }\n    _clearSubscribedState() {\n        this._clearRefreshTimeout();\n    }\n    _setSubscribed(result) {\n        if (!this._isSubscribing()) {\n            return;\n        }\n        this._clearSubscribingState();\n        if (result.recoverable) {\n            this._recover = true;\n            this._offset = result.offset || 0;\n            this._epoch = result.epoch || '';\n        }\n        this._setState(types_1.SubscriptionState.Subscribed);\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        const ctx = this._centrifuge._getSubscribeContext(this.channel, result);\n        this.emit('subscribed', ctx);\n        this._resolvePromises();\n        const pubs = result.publications;\n        if (pubs && pubs.length > 0) {\n            for (const i in pubs) {\n                if (!pubs.hasOwnProperty(i)) {\n                    continue;\n                }\n                this._handlePublication(pubs[i]);\n            }\n        }\n        if (result.expires === true) {\n            this._refreshTimeout = setTimeout(() => this._refresh(), (0, utils_1.ttlMilliseconds)(result.ttl));\n        }\n    }\n    _setSubscribing(code, reason) {\n        if (this._isSubscribing()) {\n            return;\n        }\n        if (this._isSubscribed()) {\n            this._clearSubscribedState();\n        }\n        if (this._setState(types_1.SubscriptionState.Subscribing)) {\n            this.emit('subscribing', { channel: this.channel, code: code, reason: reason });\n        }\n        this._subscribe(false, false);\n    }\n    _subscribe(optimistic, skipSending) {\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        this._centrifuge._debug('subscribing on', this.channel);\n        if (this._centrifuge.state !== types_1.State.Connected && !optimistic) {\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            this._centrifuge._debug('delay subscribe on', this.channel, 'till connected');\n            // subscribe will be called later automatically.\n            return null;\n        }\n        if (this._usesToken()) {\n            // token channel, need to get token before sending subscribe.\n            if (this._token) {\n                return this._sendSubscribe(this._token, skipSending);\n            }\n            else {\n                if (optimistic) {\n                    return null;\n                }\n                const self = this;\n                this._getSubscriptionToken().then(function (token) {\n                    if (!self._isSubscribing()) {\n                        return;\n                    }\n                    if (!token) {\n                        self._failUnauthorized();\n                        return;\n                    }\n                    self._token = token;\n                    self._sendSubscribe(token, false);\n                }).catch(function (e) {\n                    if (!self._isSubscribing()) {\n                        return;\n                    }\n                    self.emit('error', {\n                        type: 'subscribeToken',\n                        channel: self.channel,\n                        error: {\n                            code: codes_1.errorCodes.subscriptionSubscribeToken,\n                            message: e !== undefined ? e.toString() : ''\n                        }\n                    });\n                    self._scheduleResubscribe();\n                });\n                return null;\n            }\n        }\n        else {\n            return this._sendSubscribe('', skipSending);\n        }\n    }\n    _sendSubscribe(token, skipSending) {\n        const channel = this.channel;\n        const req = {\n            channel: channel\n        };\n        if (token) {\n            req.token = token;\n        }\n        if (this._data) {\n            req.data = this._data;\n        }\n        if (this._positioned) {\n            req.positioned = true;\n        }\n        if (this._recoverable) {\n            req.recoverable = true;\n        }\n        if (this._joinLeave) {\n            req.join_leave = true;\n        }\n        if (this._needRecover()) {\n            req.recover = true;\n            const offset = this._getOffset();\n            if (offset) {\n                req.offset = offset;\n            }\n            const epoch = this._getEpoch();\n            if (epoch) {\n                req.epoch = epoch;\n            }\n        }\n        const cmd = { subscribe: req };\n        this._inflight = true;\n        // @ts-ignore – we are hiding some symbols from public API autocompletion.\n        this._centrifuge._call(cmd, skipSending).then(resolveCtx => {\n            this._inflight = false;\n            // @ts-ignore - improve later.\n            const result = resolveCtx.reply.subscribe;\n            this._handleSubscribeResponse(result);\n            // @ts-ignore - improve later.\n            if (resolveCtx.next) {\n                // @ts-ignore - improve later.\n                resolveCtx.next();\n            }\n        }, rejectCtx => {\n            this._inflight = false;\n            this._handleSubscribeError(rejectCtx.error);\n            if (rejectCtx.next) {\n                rejectCtx.next();\n            }\n        });\n        return cmd;\n    }\n    _handleSubscribeError(error) {\n        if (!this._isSubscribing()) {\n            return;\n        }\n        if (error.code === codes_1.errorCodes.timeout) {\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            this._centrifuge._disconnect(codes_1.connectingCodes.subscribeTimeout, 'subscribe timeout', true);\n            return;\n        }\n        this._subscribeError(error);\n    }\n    _handleSubscribeResponse(result) {\n        if (!this._isSubscribing()) {\n            return;\n        }\n        this._setSubscribed(result);\n    }\n    _setUnsubscribed(code, reason, sendUnsubscribe) {\n        if (this._isUnsubscribed()) {\n            return;\n        }\n        if (this._isSubscribed()) {\n            if (sendUnsubscribe) {\n                // @ts-ignore – we are hiding some methods from public API autocompletion.\n                this._centrifuge._unsubscribe(this);\n            }\n            this._clearSubscribedState();\n        }\n        if (this._isSubscribing()) {\n            this._clearSubscribingState();\n        }\n        if (this._setState(types_1.SubscriptionState.Unsubscribed)) {\n            this.emit('unsubscribed', { channel: this.channel, code: code, reason: reason });\n        }\n        this._rejectPromises({ code: codes_1.errorCodes.subscriptionUnsubscribed, message: this.state });\n    }\n    _handlePublication(pub) {\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        const ctx = this._centrifuge._getPublicationContext(this.channel, pub);\n        this.emit('publication', ctx);\n        if (pub.offset) {\n            this._offset = pub.offset;\n        }\n    }\n    _handleJoin(join) {\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        const info = this._centrifuge._getJoinLeaveContext(join.info);\n        this.emit('join', { channel: this.channel, info: info });\n    }\n    _handleLeave(leave) {\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        const info = this._centrifuge._getJoinLeaveContext(leave.info);\n        this.emit('leave', { channel: this.channel, info: info });\n    }\n    _resolvePromises() {\n        for (const id in this._promises) {\n            if (this._promises[id].timeout) {\n                clearTimeout(this._promises[id].timeout);\n            }\n            this._promises[id].resolve();\n            delete this._promises[id];\n        }\n    }\n    _rejectPromises(err) {\n        for (const id in this._promises) {\n            if (this._promises[id].timeout) {\n                clearTimeout(this._promises[id].timeout);\n            }\n            this._promises[id].reject(err);\n            delete this._promises[id];\n        }\n    }\n    _scheduleResubscribe() {\n        const self = this;\n        const delay = this._getResubscribeDelay();\n        this._resubscribeTimeout = setTimeout(function () {\n            if (self._isSubscribing()) {\n                self._subscribe(false, false);\n            }\n        }, delay);\n    }\n    _subscribeError(err) {\n        if (!this._isSubscribing()) {\n            return;\n        }\n        if (err.code < 100 || err.code === 109 || err.temporary === true) {\n            if (err.code === 109) { // Token expired error.\n                this._token = null;\n            }\n            const errContext = {\n                channel: this.channel,\n                type: 'subscribe',\n                error: err\n            };\n            if (this._centrifuge.state === types_1.State.Connected) {\n                this.emit('error', errContext);\n            }\n            this._scheduleResubscribe();\n        }\n        else {\n            this._setUnsubscribed(err.code, err.message, false);\n        }\n    }\n    _getResubscribeDelay() {\n        const delay = (0, utils_1.backoff)(this._resubscribeAttempts, this._minResubscribeDelay, this._maxResubscribeDelay);\n        this._resubscribeAttempts++;\n        return delay;\n    }\n    _setOptions(options) {\n        if (!options) {\n            return;\n        }\n        if (options.since) {\n            this._offset = options.since.offset;\n            this._epoch = options.since.epoch;\n            this._recover = true;\n        }\n        if (options.data) {\n            this._data = options.data;\n        }\n        if (options.minResubscribeDelay !== undefined) {\n            this._minResubscribeDelay = options.minResubscribeDelay;\n        }\n        if (options.maxResubscribeDelay !== undefined) {\n            this._maxResubscribeDelay = options.maxResubscribeDelay;\n        }\n        if (options.token) {\n            this._token = options.token;\n        }\n        if (options.getToken) {\n            this._getToken = options.getToken;\n        }\n        if (options.positioned === true) {\n            this._positioned = true;\n        }\n        if (options.recoverable === true) {\n            this._recoverable = true;\n        }\n        if (options.joinLeave === true) {\n            this._joinLeave = true;\n        }\n    }\n    _getOffset() {\n        const offset = this._offset;\n        if (offset !== null) {\n            return offset;\n        }\n        return 0;\n    }\n    _getEpoch() {\n        const epoch = this._epoch;\n        if (epoch !== null) {\n            return epoch;\n        }\n        return '';\n    }\n    _clearRefreshTimeout() {\n        if (this._refreshTimeout !== null) {\n            clearTimeout(this._refreshTimeout);\n            this._refreshTimeout = null;\n        }\n    }\n    _clearResubscribeTimeout() {\n        if (this._resubscribeTimeout !== null) {\n            clearTimeout(this._resubscribeTimeout);\n            this._resubscribeTimeout = null;\n        }\n    }\n    _getSubscriptionToken() {\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        this._centrifuge._debug('get subscription token for channel', this.channel);\n        const ctx = {\n            channel: this.channel\n        };\n        const getToken = this._getToken;\n        if (getToken === null) {\n            throw new Error('provide a function to get channel subscription token');\n        }\n        return getToken(ctx);\n    }\n    _refresh() {\n        this._clearRefreshTimeout();\n        const self = this;\n        this._getSubscriptionToken().then(function (token) {\n            if (!self._isSubscribed()) {\n                return;\n            }\n            if (!token) {\n                self._failUnauthorized();\n                return;\n            }\n            self._token = token;\n            const req = {\n                channel: self.channel,\n                token: token\n            };\n            const msg = {\n                'sub_refresh': req\n            };\n            // @ts-ignore – we are hiding some symbols from public API autocompletion.\n            self._centrifuge._call(msg).then(resolveCtx => {\n                // @ts-ignore - improve later.\n                const result = resolveCtx.reply.sub_refresh;\n                self._refreshResponse(result);\n                // @ts-ignore - improve later.\n                if (resolveCtx.next) {\n                    // @ts-ignore - improve later.\n                    resolveCtx.next();\n                }\n            }, rejectCtx => {\n                self._refreshError(rejectCtx.error);\n                if (rejectCtx.next) {\n                    rejectCtx.next();\n                }\n            });\n        }).catch(function (e) {\n            self.emit('error', {\n                type: 'refreshToken',\n                channel: self.channel,\n                error: {\n                    code: codes_1.errorCodes.subscriptionRefreshToken,\n                    message: e !== undefined ? e.toString() : ''\n                }\n            });\n            self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n        });\n    }\n    _refreshResponse(result) {\n        if (!this._isSubscribed()) {\n            return;\n        }\n        // @ts-ignore – we are hiding some methods from public API autocompletion.\n        this._centrifuge._debug('subscription token refreshed, channel', this.channel);\n        this._clearRefreshTimeout();\n        if (result.expires === true) {\n            this._refreshTimeout = setTimeout(() => this._refresh(), (0, utils_1.ttlMilliseconds)(result.ttl));\n        }\n    }\n    _refreshError(err) {\n        if (!this._isSubscribed()) {\n            return;\n        }\n        if (err.code < 100 || err.temporary === true) {\n            this.emit('error', {\n                type: 'refresh',\n                channel: this.channel,\n                error: err\n            });\n            this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n        }\n        else {\n            this._setUnsubscribed(err.code, err.message, true);\n        }\n    }\n    _getRefreshRetryDelay() {\n        return (0, utils_1.backoff)(0, 10000, 20000);\n    }\n    _failUnauthorized() {\n        this._setUnsubscribed(codes_1.unsubscribedCodes.unauthorized, 'unauthorized', true);\n    }\n}\nexports.Subscription = Subscription;\n//# sourceMappingURL=subscription.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unsubscribedCodes = exports.subscribingCodes = exports.disconnectedCodes = exports.connectingCodes = exports.errorCodes = void 0;\nexports.errorCodes = {\n    timeout: 1,\n    transportClosed: 2,\n    clientDisconnected: 3,\n    clientClosed: 4,\n    clientConnectToken: 5,\n    clientRefreshToken: 6,\n    subscriptionUnsubscribed: 7,\n    subscriptionSubscribeToken: 8,\n    subscriptionRefreshToken: 9,\n    transportWriteError: 10,\n    connectionClosed: 11\n};\nexports.connectingCodes = {\n    connectCalled: 0,\n    transportClosed: 1,\n    noPing: 2,\n    subscribeTimeout: 3,\n    unsubscribeError: 4\n};\nexports.disconnectedCodes = {\n    disconnectCalled: 0,\n    unauthorized: 1,\n    badProtocol: 2,\n    messageSizeLimit: 3\n};\nexports.subscribingCodes = {\n    subscribeCalled: 0,\n    transportClosed: 1\n};\nexports.unsubscribedCodes = {\n    unsubscribeCalled: 0,\n    unauthorized: 1,\n    clientClosed: 2\n};\n//# sourceMappingURL=codes.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SubscriptionState = exports.State = void 0;\n/** State of client. */\nvar State;\n(function (State) {\n    State[\"Disconnected\"] = \"disconnected\";\n    State[\"Connecting\"] = \"connecting\";\n    State[\"Connected\"] = \"connected\";\n})(State = exports.State || (exports.State = {}));\n/** State of Subscription */\nvar SubscriptionState;\n(function (SubscriptionState) {\n    SubscriptionState[\"Unsubscribed\"] = \"unsubscribed\";\n    SubscriptionState[\"Subscribing\"] = \"subscribing\";\n    SubscriptionState[\"Subscribed\"] = \"subscribed\";\n})(SubscriptionState = exports.SubscriptionState || (exports.SubscriptionState = {}));\n//# sourceMappingURL=types.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ttlMilliseconds = exports.errorExists = exports.backoff = exports.log = exports.isFunction = exports.startsWith = void 0;\n/** @internal */\nfunction startsWith(value, prefix) {\n    return value.lastIndexOf(prefix, 0) === 0;\n}\nexports.startsWith = startsWith;\n/** @internal */\nfunction isFunction(value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return typeof value === 'function';\n}\nexports.isFunction = isFunction;\n/** @internal */\nfunction log(level, args) {\n    if (globalThis.console) {\n        const logger = globalThis.console[level];\n        if (isFunction(logger)) {\n            logger.apply(globalThis.console, args);\n        }\n    }\n}\nexports.log = log;\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/** @internal */\nfunction backoff(step, min, max) {\n    // Full jitter technique, see:\n    // https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n    if (step > 31) {\n        step = 31;\n    }\n    const interval = randomInt(0, Math.min(max, min * Math.pow(2, step)));\n    return Math.min(max, min + interval);\n}\nexports.backoff = backoff;\n/** @internal */\nfunction errorExists(data) {\n    return 'error' in data && data.error !== null;\n}\nexports.errorExists = errorExists;\n/** @internal */\nfunction ttlMilliseconds(ttl) {\n    // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n    return Math.min(ttl * 1000, 2147483647);\n}\nexports.ttlMilliseconds = ttlMilliseconds;\n//# sourceMappingURL=utils.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SockjsTransport = void 0;\n/** @internal */\nclass SockjsTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._transport = null;\n    }\n    name() {\n        return 'sockjs';\n    }\n    subName() {\n        return 'sockjs-' + this._transport.transport;\n    }\n    emulation() {\n        return false;\n    }\n    supported() {\n        return this.options.sockjs !== null;\n    }\n    initialize(_protocol, callbacks) {\n        this._transport = new this.options.sockjs(this.endpoint, null, this.options.sockjsOptions);\n        this._transport.onopen = () => {\n            callbacks.onOpen();\n        };\n        this._transport.onerror = e => {\n            callbacks.onError(e);\n        };\n        this._transport.onclose = closeEvent => {\n            callbacks.onClose(closeEvent);\n        };\n        this._transport.onmessage = event => {\n            callbacks.onMessage(event.data);\n        };\n    }\n    close() {\n        this._transport.close();\n    }\n    send(data) {\n        this._transport.send(data);\n    }\n}\nexports.SockjsTransport = SockjsTransport;\n//# sourceMappingURL=transport_sockjs.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebsocketTransport = void 0;\n/** @internal */\nclass WebsocketTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._transport = null;\n    }\n    name() {\n        return 'websocket';\n    }\n    subName() {\n        return 'websocket';\n    }\n    emulation() {\n        return false;\n    }\n    supported() {\n        return this.options.websocket !== undefined && this.options.websocket !== null;\n    }\n    initialize(protocol, callbacks) {\n        let subProtocol = '';\n        if (protocol === 'protobuf') {\n            subProtocol = 'centrifuge-protobuf';\n        }\n        if (subProtocol !== '') {\n            this._transport = new this.options.websocket(this.endpoint, subProtocol);\n        }\n        else {\n            this._transport = new this.options.websocket(this.endpoint);\n        }\n        if (protocol === 'protobuf') {\n            this._transport.binaryType = 'arraybuffer';\n        }\n        this._transport.onopen = () => {\n            callbacks.onOpen();\n        };\n        this._transport.onerror = e => {\n            callbacks.onError(e);\n        };\n        this._transport.onclose = closeEvent => {\n            callbacks.onClose(closeEvent);\n        };\n        this._transport.onmessage = event => {\n            callbacks.onMessage(event.data);\n        };\n    }\n    close() {\n        this._transport.close();\n    }\n    send(data) {\n        this._transport.send(data);\n    }\n}\nexports.WebsocketTransport = WebsocketTransport;\n//# sourceMappingURL=transport_websocket.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpStreamTransport = void 0;\n/** @internal */\nclass HttpStreamTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._abortController = null;\n        this._utf8decoder = new TextDecoder();\n        this._protocol = 'json';\n    }\n    name() {\n        return 'http_stream';\n    }\n    subName() {\n        return 'http_stream';\n    }\n    emulation() {\n        return true;\n    }\n    _handleErrors(response) {\n        if (!response.ok)\n            throw new Error(response.status);\n        return response;\n    }\n    _fetchEventTarget(self, endpoint, options) {\n        const eventTarget = new EventTarget();\n        // fetch with connection timeout maybe? https://github.com/github/fetch/issues/175\n        const fetchFunc = self.options.fetch;\n        fetchFunc(endpoint, options)\n            .then(self._handleErrors)\n            .then(response => {\n            eventTarget.dispatchEvent(new Event('open'));\n            let jsonStreamBuf = '';\n            let jsonStreamPos = 0;\n            let protoStreamBuf = new Uint8Array();\n            const reader = response.body.getReader();\n            return new self.options.readableStream({\n                start(controller) {\n                    function pump() {\n                        return reader.read().then(({ done, value }) => {\n                            // When no more data needs to be consumed, close the stream\n                            if (done) {\n                                eventTarget.dispatchEvent(new Event('close'));\n                                controller.close();\n                                return;\n                            }\n                            try {\n                                if (self._protocol === 'json') {\n                                    jsonStreamBuf += self._utf8decoder.decode(value);\n                                    while (jsonStreamPos < jsonStreamBuf.length) {\n                                        if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                                            const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                                            eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                                            jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                                            jsonStreamPos = 0;\n                                        }\n                                        else {\n                                            ++jsonStreamPos;\n                                        }\n                                    }\n                                }\n                                else {\n                                    const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n                                    mergedArray.set(protoStreamBuf);\n                                    mergedArray.set(value, protoStreamBuf.length);\n                                    protoStreamBuf = mergedArray;\n                                    while (true) {\n                                        const result = self.options.decoder.decodeReply(protoStreamBuf);\n                                        if (result.ok) {\n                                            const data = protoStreamBuf.slice(0, result.pos);\n                                            eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                                            protoStreamBuf = protoStreamBuf.slice(result.pos);\n                                            continue;\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                            catch (error) {\n                                // @ts-ignore - improve later.\n                                eventTarget.dispatchEvent(new Event('error', { detail: error }));\n                                eventTarget.dispatchEvent(new Event('close'));\n                                controller.close();\n                                return;\n                            }\n                            pump();\n                        }).catch(function (e) {\n                            // @ts-ignore - improve later.\n                            eventTarget.dispatchEvent(new Event('error', { detail: e }));\n                            eventTarget.dispatchEvent(new Event('close'));\n                            controller.close();\n                            return;\n                        });\n                    }\n                    return pump();\n                }\n            });\n        })\n            .catch(error => {\n            // @ts-ignore - improve later.\n            eventTarget.dispatchEvent(new Event('error', { detail: error }));\n            eventTarget.dispatchEvent(new Event('close'));\n        });\n        return eventTarget;\n    }\n    supported() {\n        return this.options.fetch !== null &&\n            this.options.readableStream !== null &&\n            typeof TextDecoder !== 'undefined' &&\n            typeof AbortController !== 'undefined' &&\n            typeof EventTarget !== 'undefined' &&\n            typeof Event !== 'undefined' &&\n            typeof MessageEvent !== 'undefined' &&\n            typeof Error !== 'undefined';\n    }\n    initialize(protocol, callbacks, initialData) {\n        this._protocol = protocol;\n        this._abortController = new AbortController();\n        let headers;\n        let body;\n        if (protocol === 'json') {\n            headers = {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json'\n            };\n            body = initialData;\n        }\n        else {\n            headers = {\n                'Accept': 'application/octet-stream',\n                'Content-Type': 'application/octet-stream'\n            };\n            body = initialData;\n        }\n        const fetchOptions = {\n            method: 'POST',\n            headers: headers,\n            body: body,\n            mode: 'cors',\n            credentials: 'same-origin',\n            cache: 'no-cache',\n            signal: this._abortController.signal\n        };\n        const eventTarget = this._fetchEventTarget(this, this.endpoint, fetchOptions);\n        eventTarget.addEventListener('open', () => {\n            callbacks.onOpen();\n        });\n        eventTarget.addEventListener('error', (e) => {\n            this._abortController.abort();\n            callbacks.onError(e);\n        });\n        eventTarget.addEventListener('close', () => {\n            this._abortController.abort();\n            callbacks.onClose({\n                code: 4,\n                reason: 'connection closed'\n            });\n        });\n        eventTarget.addEventListener('message', (e) => {\n            callbacks.onMessage(e.data);\n        });\n    }\n    close() {\n        this._abortController.abort();\n    }\n    send(data, session, node) {\n        let headers;\n        let body;\n        const req = {\n            session: session,\n            node: node,\n            data: data\n        };\n        if (this._protocol === 'json') {\n            headers = {\n                'Content-Type': 'application/json'\n            };\n            body = JSON.stringify(req);\n        }\n        else {\n            headers = {\n                'Content-Type': 'application/octet-stream'\n            };\n            body = this.options.encoder.encodeEmulationRequest(req);\n        }\n        const fetchFunc = this.options.fetch;\n        const fetchOptions = {\n            method: 'POST',\n            headers: headers,\n            body: body,\n            mode: 'cors',\n            credentials: 'same-origin',\n            cache: 'no-cache'\n        };\n        fetchFunc(this.options.emulationEndpoint, fetchOptions);\n    }\n}\nexports.HttpStreamTransport = HttpStreamTransport;\n//# sourceMappingURL=transport_http_stream.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SseTransport = void 0;\n/** @internal */\nclass SseTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._protocol = 'json';\n        this._transport = null;\n        this._onClose = null;\n    }\n    name() {\n        return 'sse';\n    }\n    subName() {\n        return 'sse';\n    }\n    emulation() {\n        return true;\n    }\n    supported() {\n        return this.options.eventsource !== null && this.options.fetch !== null;\n    }\n    initialize(_protocol, callbacks, initialData) {\n        let url;\n        if (globalThis && globalThis.document && globalThis.document.baseURI) {\n            // Handle case when endpoint is relative, like //example.com/connection/sse\n            url = new URL(this.endpoint, globalThis.document.baseURI);\n        }\n        else {\n            url = new URL(this.endpoint);\n        }\n        url.searchParams.append('cf_connect', initialData);\n        const eventsourceOptions = {};\n        const eventSource = new this.options.eventsource(url.toString(), eventsourceOptions);\n        this._transport = eventSource;\n        const self = this;\n        eventSource.onopen = function () {\n            callbacks.onOpen();\n        };\n        eventSource.onerror = function (e) {\n            eventSource.close();\n            callbacks.onError(e);\n            callbacks.onClose({\n                code: 4,\n                reason: 'connection closed'\n            });\n        };\n        eventSource.onmessage = function (e) {\n            callbacks.onMessage(e.data);\n        };\n        self._onClose = function () {\n            callbacks.onClose({\n                code: 4,\n                reason: 'connection closed'\n            });\n        };\n    }\n    close() {\n        this._transport.close();\n        if (this._onClose !== null) {\n            this._onClose();\n        }\n    }\n    send(data, session, node) {\n        const req = {\n            session: session,\n            node: node,\n            data: data\n        };\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        const body = JSON.stringify(req);\n        const fetchFunc = this.options.fetch;\n        const fetchOptions = {\n            method: 'POST',\n            headers: headers,\n            body: body,\n            mode: 'cors',\n            credentials: 'same-origin',\n            cache: 'no-cache'\n        };\n        fetchFunc(this.options.emulationEndpoint, fetchOptions);\n    }\n}\nexports.SseTransport = SseTransport;\n//# sourceMappingURL=transport_sse.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebtransportTransport = void 0;\n/** @internal */\nclass WebtransportTransport {\n    constructor(endpoint, options) {\n        this.endpoint = endpoint;\n        this.options = options;\n        this._transport = null;\n        this._stream = null;\n        this._writer = null;\n        this._utf8decoder = new TextDecoder();\n        this._protocol = 'json';\n    }\n    name() {\n        return 'webtransport';\n    }\n    subName() {\n        return 'webtransport';\n    }\n    emulation() {\n        return false;\n    }\n    supported() {\n        return this.options.webtransport !== undefined && this.options.webtransport !== null;\n    }\n    initialize(protocol, callbacks) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url;\n            if (globalThis && globalThis.document && globalThis.document.baseURI) {\n                // Handle case when endpoint is relative, like //example.com/connection/webtransport\n                url = new URL(this.endpoint, globalThis.document.baseURI);\n            }\n            else {\n                url = new URL(this.endpoint);\n            }\n            if (protocol === 'protobuf') {\n                url.searchParams.append('cf_protocol', 'protobuf');\n            }\n            this._protocol = protocol;\n            const eventTarget = new EventTarget();\n            this._transport = new this.options.webtransport(url.toString());\n            this._transport.closed.then(() => {\n                callbacks.onClose({\n                    code: 4,\n                    reason: 'connection closed'\n                });\n            }).catch(() => {\n                callbacks.onClose({\n                    code: 4,\n                    reason: 'connection closed'\n                });\n            });\n            try {\n                yield this._transport.ready;\n            }\n            catch (_a) {\n                this.close();\n                return;\n            }\n            let stream;\n            try {\n                stream = yield this._transport.createBidirectionalStream();\n            }\n            catch (_b) {\n                this.close();\n                return;\n            }\n            this._stream = stream;\n            this._writer = this._stream.writable.getWriter();\n            eventTarget.addEventListener('close', () => {\n                callbacks.onClose({\n                    code: 4,\n                    reason: 'connection closed'\n                });\n            });\n            eventTarget.addEventListener('message', (e) => {\n                callbacks.onMessage(e.data);\n            });\n            this._startReading(eventTarget);\n            callbacks.onOpen();\n        });\n    }\n    _startReading(eventTarget) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const reader = this._stream.readable.getReader();\n            let jsonStreamBuf = '';\n            let jsonStreamPos = 0;\n            let protoStreamBuf = new Uint8Array();\n            try {\n                while (true) {\n                    const { done, value } = yield reader.read();\n                    if (value.length > 0) {\n                        if (this._protocol === 'json') {\n                            jsonStreamBuf += this._utf8decoder.decode(value);\n                            while (jsonStreamPos < jsonStreamBuf.length) {\n                                if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                                    const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                                    eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                                    jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                                    jsonStreamPos = 0;\n                                }\n                                else {\n                                    ++jsonStreamPos;\n                                }\n                            }\n                        }\n                        else {\n                            const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n                            mergedArray.set(protoStreamBuf);\n                            mergedArray.set(value, protoStreamBuf.length);\n                            protoStreamBuf = mergedArray;\n                            while (true) {\n                                const result = this.options.decoder.decodeReply(protoStreamBuf);\n                                if (result.ok) {\n                                    const data = protoStreamBuf.slice(0, result.pos);\n                                    eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                                    protoStreamBuf = protoStreamBuf.slice(result.pos);\n                                    continue;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    if (done) {\n                        break;\n                    }\n                }\n            }\n            catch (_a) {\n                eventTarget.dispatchEvent(new Event('close'));\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this._writer) {\n                    yield this._writer.close();\n                }\n                this._transport.close();\n            }\n            catch (e) {\n                // already closed.\n            }\n        });\n    }\n    send(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let binary;\n            if (this._protocol === 'json') {\n                // Need extra \\n since WT is non-frame protocol. \n                binary = new TextEncoder().encode(data + '\\n');\n            }\n            else {\n                binary = data;\n            }\n            try {\n                yield this._writer.write(binary);\n            }\n            catch (e) {\n                this.close();\n            }\n        });\n    }\n}\nexports.WebtransportTransport = WebtransportTransport;\n//# sourceMappingURL=transport_webtransport.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonDecoder = exports.JsonEncoder = void 0;\n/** @internal */\nclass JsonEncoder {\n    encodeCommands(commands) {\n        return commands.map(c => JSON.stringify(c)).join('\\n');\n    }\n}\nexports.JsonEncoder = JsonEncoder;\n/** @internal */\nclass JsonDecoder {\n    decodeReplies(data) {\n        return data.trim().split('\\n').map(r => JSON.parse(r));\n    }\n}\nexports.JsonDecoder = JsonDecoder;\n//# sourceMappingURL=json.js.map"]}